{
  "version": 3,
  "sources": ["../../ngeohash/main.js"],
  "sourcesContent": ["/**\r\n * Copyright (c) 2011, Sun Ning.\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use, copy,\r\n * modify, merge, publish, distribute, sublicense, and/or sell copies\r\n * of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\r\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *\r\n */\r\n\r\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\r\nvar BASE32_CODES_DICT = {};\r\nfor (var i = 0; i < BASE32_CODES.length; i++) {\r\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\r\n}\r\n\r\nvar ENCODE_AUTO = 'auto';\r\n\r\nvar MIN_LAT = -90;\r\nvar MAX_LAT = 90;\r\nvar MIN_LON = -180;\r\nvar MAX_LON = 180;\r\n/**\r\n * Significant Figure Hash Length\r\n *\r\n * This is a quick and dirty lookup to figure out how long our hash\r\n * should be in order to guarantee a certain amount of trailing\r\n * significant figures. This was calculated by determining the error:\r\n * 45/2^(n-1) where n is the number of bits for a latitude or\r\n * longitude. Key is # of desired sig figs, value is minimum length of\r\n * the geohash.\r\n * @type Array\r\n */\r\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\r\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\r\n/**\r\n * Encode\r\n *\r\n * Create a Geohash out of a latitude and longitude that is\r\n * `numberOfChars` long.\r\n *\r\n * @param {Number|String} latitude\r\n * @param {Number|String} longitude\r\n * @param {Number} numberOfChars\r\n * @returns {String}\r\n */\r\nvar encode = function (latitude, longitude, numberOfChars) {\r\n  if (numberOfChars === ENCODE_AUTO) {\r\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\r\n      throw new Error('string notation required for auto precision.');\r\n    }\r\n    var decSigFigsLat = latitude.split('.')[1].length;\r\n    var decSigFigsLong = longitude.split('.')[1].length;\r\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\r\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\r\n  } else if (numberOfChars === undefined) {\r\n    numberOfChars = 9;\r\n  }\r\n\r\n  var chars = [],\r\n  bits = 0,\r\n  bitsTotal = 0,\r\n  hash_value = 0,\r\n  maxLat = MAX_LAT,\r\n  minLat = MIN_LAT,\r\n  maxLon = MAX_LON,\r\n  minLon = MIN_LON,\r\n  mid;\r\n  while (chars.length < numberOfChars) {\r\n    if (bitsTotal % 2 === 0) {\r\n      mid = (maxLon + minLon) / 2;\r\n      if (longitude > mid) {\r\n        hash_value = (hash_value << 1) + 1;\r\n        minLon = mid;\r\n      } else {\r\n        hash_value = (hash_value << 1) + 0;\r\n        maxLon = mid;\r\n      }\r\n    } else {\r\n      mid = (maxLat + minLat) / 2;\r\n      if (latitude > mid) {\r\n        hash_value = (hash_value << 1) + 1;\r\n        minLat = mid;\r\n      } else {\r\n        hash_value = (hash_value << 1) + 0;\r\n        maxLat = mid;\r\n      }\r\n    }\r\n\r\n    bits++;\r\n    bitsTotal++;\r\n    if (bits === 5) {\r\n      var code = BASE32_CODES[hash_value];\r\n      chars.push(code);\r\n      bits = 0;\r\n      hash_value = 0;\r\n    }\r\n  }\r\n  return chars.join('');\r\n};\r\n\r\n/**\r\n * Encode Integer\r\n *\r\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\r\n *\r\n * @param {Number} latitude\r\n * @param {Number} longitude\r\n * @param {Number} bitDepth\r\n * @returns {Number}\r\n */\r\nvar encode_int = function (latitude, longitude, bitDepth) {\r\n\r\n  bitDepth = bitDepth || 52;\r\n\r\n  var bitsTotal = 0,\r\n  maxLat = MAX_LAT,\r\n  minLat = MIN_LAT,\r\n  maxLon = MAX_LON,\r\n  minLon = MIN_LON,\r\n  mid,\r\n  combinedBits = 0;\r\n\r\n  while (bitsTotal < bitDepth) {\r\n    combinedBits *= 2;\r\n    if (bitsTotal % 2 === 0) {\r\n      mid = (maxLon + minLon) / 2;\r\n      if (longitude > mid) {\r\n        combinedBits += 1;\r\n        minLon = mid;\r\n      } else {\r\n        maxLon = mid;\r\n      }\r\n    } else {\r\n      mid = (maxLat + minLat) / 2;\r\n      if (latitude > mid) {\r\n        combinedBits += 1;\r\n        minLat = mid;\r\n      } else {\r\n        maxLat = mid;\r\n      }\r\n    }\r\n    bitsTotal++;\r\n  }\r\n  return combinedBits;\r\n};\r\n\r\n/**\r\n * Decode Bounding Box\r\n *\r\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\r\n * @param {String} hash_string\r\n * @returns {Array}\r\n */\r\nvar decode_bbox = function (hash_string) {\r\n  var isLon = true,\r\n    maxLat = MAX_LAT,\r\n    minLat = MIN_LAT,\r\n    maxLon = MAX_LON,\r\n    minLon = MIN_LON,\r\n    mid;\r\n\r\n  var hashValue = 0;\r\n  for (var i = 0, l = hash_string.length; i < l; i++) {\r\n    var code = hash_string[i].toLowerCase();\r\n    hashValue = BASE32_CODES_DICT[code];\r\n\r\n    for (var bits = 4; bits >= 0; bits--) {\r\n      var bit = (hashValue >> bits) & 1;\r\n      if (isLon) {\r\n        mid = (maxLon + minLon) / 2;\r\n        if (bit === 1) {\r\n          minLon = mid;\r\n        } else {\r\n          maxLon = mid;\r\n        }\r\n      } else {\r\n        mid = (maxLat + minLat) / 2;\r\n        if (bit === 1) {\r\n          minLat = mid;\r\n        } else {\r\n          maxLat = mid;\r\n        }\r\n      }\r\n      isLon = !isLon;\r\n    }\r\n  }\r\n  return [minLat, minLon, maxLat, maxLon];\r\n};\r\n\r\n/**\r\n * Decode Bounding Box Integer\r\n *\r\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\r\n * @param {Number} hashInt\r\n * @param {Number} bitDepth\r\n * @returns {Array}\r\n */\r\nvar decode_bbox_int = function (hashInt, bitDepth) {\r\n\r\n  bitDepth = bitDepth || 52;\r\n\r\n  var maxLat = MAX_LAT,\r\n  minLat = MIN_LAT,\r\n  maxLon = MAX_LON,\r\n  minLon = MIN_LON;\r\n\r\n  var latBit = 0, lonBit = 0;\r\n  var step = bitDepth / 2;\r\n\r\n  for (var i = 0; i < step; i++) {\r\n\r\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\r\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\r\n\r\n    if (latBit === 0) {\r\n      maxLat = (maxLat + minLat) / 2;\r\n    }\r\n    else {\r\n      minLat = (maxLat + minLat) / 2;\r\n    }\r\n\r\n    if (lonBit === 0) {\r\n      maxLon = (maxLon + minLon) / 2;\r\n    }\r\n    else {\r\n      minLon = (maxLon + minLon) / 2;\r\n    }\r\n  }\r\n  return [minLat, minLon, maxLat, maxLon];\r\n};\r\n\r\nfunction get_bit(bits, position) {\r\n  return (bits / Math.pow(2, position)) & 0x01;\r\n}\r\n\r\n/**\r\n * Decode\r\n *\r\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\r\n * `longitude` and `error`.\r\n * @param {String} hashString\r\n * @returns {Object}\r\n */\r\nvar decode = function (hashString) {\r\n  var bbox = decode_bbox(hashString);\r\n  var lat = (bbox[0] + bbox[2]) / 2;\r\n  var lon = (bbox[1] + bbox[3]) / 2;\r\n  var latErr = bbox[2] - lat;\r\n  var lonErr = bbox[3] - lon;\r\n  return {latitude: lat, longitude: lon,\r\n      error: {latitude: latErr, longitude: lonErr}};\r\n};\r\n\r\n/**\r\n * Decode Integer\r\n *\r\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\r\n * `longitude` and `error`.\r\n * @param {Number} hash_int\r\n * @param {Number} bitDepth\r\n * @returns {Object}\r\n */\r\nvar decode_int = function (hash_int, bitDepth) {\r\n  var bbox = decode_bbox_int(hash_int, bitDepth);\r\n  var lat = (bbox[0] + bbox[2]) / 2;\r\n  var lon = (bbox[1] + bbox[3]) / 2;\r\n  var latErr = bbox[2] - lat;\r\n  var lonErr = bbox[3] - lon;\r\n  return {latitude: lat, longitude: lon,\r\n          error: {latitude: latErr, longitude: lonErr}};\r\n};\r\n\r\n/**\r\n * Neighbor\r\n *\r\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\r\n * direction [lat, lon], i.e.\r\n * [1,0] - north\r\n * [1,1] - northeast\r\n * ...\r\n * @param {String} hashString\r\n * @param {Array} Direction as a 2D normalized vector.\r\n * @returns {String}\r\n */\r\nvar neighbor = function (hashString, direction) {\r\n  var lonLat = decode(hashString);\r\n  var neighborLat = lonLat.latitude\r\n    + direction[0] * lonLat.error.latitude * 2;\r\n  var neighborLon = lonLat.longitude\r\n    + direction[1] * lonLat.error.longitude * 2;\r\n  neighborLon = ensure_valid_lon(neighborLon);\r\n  neighborLat = ensure_valid_lat(neighborLat);\r\n  return encode(neighborLat, neighborLon, hashString.length);\r\n};\r\n\r\n/**\r\n * Neighbor Integer\r\n *\r\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\r\n * direction [lat, lon], i.e.\r\n * [1,0] - north\r\n * [1,1] - northeast\r\n * ...\r\n * @param {String} hash_string\r\n * @returns {Array}\r\n*/\r\nvar neighbor_int = function (hash_int, direction, bitDepth) {\r\n    bitDepth = bitDepth || 52;\r\n    var lonlat = decode_int(hash_int, bitDepth);\r\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\r\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\r\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\r\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\r\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\r\n};\r\n\r\n/**\r\n * Neighbors\r\n *\r\n * Returns all neighbors' hashstrings clockwise from north around to northwest\r\n * 7 0 1\r\n * 6 x 2\r\n * 5 4 3\r\n * @param {String} hash_string\r\n * @returns {encoded neighborHashList|Array}\r\n */\r\nvar neighbors = function (hash_string) {\r\n\r\n    var hashstringLength = hash_string.length;\r\n\r\n    var lonlat = decode(hash_string);\r\n    var lat = lonlat.latitude;\r\n    var lon = lonlat.longitude;\r\n    var latErr = lonlat.error.latitude * 2;\r\n    var lonErr = lonlat.error.longitude * 2;\r\n\r\n    var neighbor_lat,\r\n        neighbor_lon;\r\n\r\n    var neighborHashList = [\r\n                            encodeNeighbor(1,0),\r\n                            encodeNeighbor(1,1),\r\n                            encodeNeighbor(0,1),\r\n                            encodeNeighbor(-1,1),\r\n                            encodeNeighbor(-1,0),\r\n                            encodeNeighbor(-1,-1),\r\n                            encodeNeighbor(0,-1),\r\n                            encodeNeighbor(1,-1)\r\n                            ];\r\n\r\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\r\n        neighbor_lat = lat + neighborLatDir * latErr;\r\n        neighbor_lon = lon + neighborLonDir * lonErr;\r\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\r\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\r\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\r\n    }\r\n\r\n    return neighborHashList;\r\n};\r\n\r\n/**\r\n * Neighbors Integer\r\n *\r\n * Returns all neighbors' hash integers clockwise from north around to northwest\r\n * 7 0 1\r\n * 6 x 2\r\n * 5 4 3\r\n * @param {Number} hash_int\r\n * @param {Number} bitDepth\r\n * @returns {encode_int'd neighborHashIntList|Array}\r\n */\r\nvar neighbors_int = function(hash_int, bitDepth){\r\n\r\n    bitDepth = bitDepth || 52;\r\n\r\n    var lonlat = decode_int(hash_int, bitDepth);\r\n    var lat = lonlat.latitude;\r\n    var lon = lonlat.longitude;\r\n    var latErr = lonlat.error.latitude * 2;\r\n    var lonErr = lonlat.error.longitude * 2;\r\n\r\n    var neighbor_lat,\r\n        neighbor_lon;\r\n\r\n    var neighborHashIntList = [\r\n                               encodeNeighbor_int(1,0),\r\n                               encodeNeighbor_int(1,1),\r\n                               encodeNeighbor_int(0,1),\r\n                               encodeNeighbor_int(-1,1),\r\n                               encodeNeighbor_int(-1,0),\r\n                               encodeNeighbor_int(-1,-1),\r\n                               encodeNeighbor_int(0,-1),\r\n                               encodeNeighbor_int(1,-1)\r\n                               ];\r\n\r\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\r\n        neighbor_lat = lat + neighborLatDir * latErr;\r\n        neighbor_lon = lon + neighborLonDir * lonErr;\r\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\r\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\r\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\r\n    }\r\n\r\n    return neighborHashIntList;\r\n};\r\n\r\n\r\n/**\r\n * Bounding Boxes\r\n *\r\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\r\n * @param {Number} minLat\r\n * @param {Number} minLon\r\n * @param {Number} maxLat\r\n * @param {Number} maxLon\r\n * @param {Number} numberOfChars\r\n * @returns {bboxes.hashList|Array}\r\n */\r\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\r\n  numberOfChars = numberOfChars || 9;\r\n\r\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\r\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\r\n\r\n  var latLon = decode(hashSouthWest);\r\n\r\n  var perLat = latLon.error.latitude * 2;\r\n  var perLon = latLon.error.longitude * 2;\r\n\r\n  var boxSouthWest = decode_bbox(hashSouthWest);\r\n  var boxNorthEast = decode_bbox(hashNorthEast);\r\n\r\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\r\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\r\n\r\n  var hashList = [];\r\n\r\n  for (var lat = 0; lat <= latStep; lat++) {\r\n    for (var lon = 0; lon <= lonStep; lon++) {\r\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\r\n    }\r\n  }\r\n\r\n  return hashList;\r\n};\r\n\r\n/**\r\n * Bounding Boxes Integer\r\n *\r\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\r\n * @param {Number} minLat\r\n * @param {Number} minLon\r\n * @param {Number} maxLat\r\n * @param {Number} maxLon\r\n * @param {Number} bitDepth\r\n * @returns {bboxes_int.hashList|Array}\r\n */\r\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\r\n    bitDepth = bitDepth || 52;\r\n\r\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\r\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\r\n\r\n    var latlon = decode_int(hashSouthWest, bitDepth);\r\n\r\n    var perLat = latlon.error.latitude * 2;\r\n    var perLon = latlon.error.longitude * 2;\r\n\r\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\r\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\r\n\r\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\r\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\r\n\r\n    var hashList = [];\r\n\r\n    for(var lat = 0; lat <= latStep; lat++){\r\n        for(var lon = 0; lon <= lonStep; lon++){\r\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\r\n        }\r\n    }\r\n\r\n  return hashList;\r\n};\r\n\r\nfunction ensure_valid_lon(lon) {\r\n  if (lon > MAX_LON)\r\n    return MIN_LON + lon % MAX_LON;\r\n  if (lon < MIN_LON)\r\n    return MAX_LON + lon % MAX_LON;\r\n  return lon;\r\n};\r\n\r\nfunction ensure_valid_lat(lat) {\r\n  if (lat > MAX_LAT)\r\n    return MAX_LAT;\r\n  if (lat < MIN_LAT)\r\n    return MIN_LAT;\r\n  return lat;\r\n};\r\n\r\nvar geohash = {\r\n  'ENCODE_AUTO': ENCODE_AUTO,\r\n  'encode': encode,\r\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\r\n  'encode_int': encode_int,\r\n  'decode': decode,\r\n  'decode_int': decode_int,\r\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\r\n  'decode_bbox': decode_bbox,\r\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\r\n  'decode_bbox_int': decode_bbox_int,\r\n  'neighbor': neighbor,\r\n  'neighbor_int': neighbor_int,\r\n  'neighbors': neighbors,\r\n  'neighbors_int': neighbors_int,\r\n  'bboxes': bboxes,\r\n  'bboxes_int': bboxes_int\r\n};\r\n\r\nmodule.exports = geohash;\r\n"],
  "mappings": "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",
  "names": ["i"]
}
